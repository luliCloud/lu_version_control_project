# Version Control System Design Document

## Classes and Data Structures

### Main Class

#### Fields

1. `Main function`: this function receive arguments to execute the git command, with the arguments are formatted as `[comamnd] [operand1] [operand2]...`. For example: `java CVS.Main [add] [file1] [file2]`. Initially, the main function determine how many arguments are received. If no argument are provided, it displays an error message. If one or more arguments are available, the function uses the first argument to match the `init` command (not included in `switch`) and other cases in `switch`statement. If the command does not match any keyword, it displays an error message stating that the command is invalid. If the operands number of format after command does not match the requirement of that command, it displays an error message stating that the operands are invalid.

2. `commandInit`: This function starts with the `initGitlet` function. This function leverages the Commit class to create the initial commit object, referred to as "commit 0". This commit is assigned a new ID, and all related information is captured in the first blob snapshot. Subsequently, a hashmap is created to manage the details of the active head pointer and the current active branch, which defaults to "main". In this initial hashmap, two key-value pairs are established: one maps <HEAD, main>, and the other maps <main, commit0_ID>. This hashmap, referred to as headAndMaster, is then saved to a file (headAndMaster) for future reference. The hashmap information is serialized into a byte stream using the Utils function, which handles the writing of this data to persistent storage.

3. `initGitlet`: this function makes two persistences if not exist: .gitlet and .gitlet/commit. The two are used to initialize a new git repository. commit folder will store the first commit blob snapshot (for init commit). 

4. `commandAdd`: This function first checks for the keyword "add" and counts the arguments that follow. If any required persistences are missing, it establishes the necessary ones. Then, it adds all the files specified in the arguments to the `STAGING_DIR` by invoking the `addToStage` function. **Note**: the add action will not add staging files to `files` hashmap (untracked).

5. `addToStage`: Helper funciton of `commandAdd`. This function duplicates the original file from the Current Working Directory (CWD) to the addition staging directory. The file is first copied to the adding staging area, with its content and format preserved identically to the original (**pre-staging**). If a file with same name already exist in the addition staging directory, it will be overwrriten. The function then retrievs the `files` hashmap <file_name, blob_id> from the parent commit.  Next, the function checks if the file hashmap already contains a file with the same name as pre-staging file. If such a file exists, the function generates the blob ID of pre-staging file (computed using utils.sha1(file name + file contents)) and then compares this hashing blobID (string) with the blod_id of the file with the same file name already stored in `files` hashmap. If they are identical, the file in the pre-staging area is removed (meaning this addition action fails because the file is already committed with identical content, not no error message shown here). As a result, the second `add` command acts like unstage commnad to call back any identical file (name and contents) added to addtion staging area. Subsequently, the commit command will verify whether the staging area is empty. 

6. `setupPersistence`: this functions sets up three persistences in .gitlet: direcory for staging files to be added, staging files to be removed, and blob files of all commits.

7. `commandRemove`: This function assists in removing files from the Current Working Directory (`CWD`) while preserving a copy in the `STAGING_RM_DIR`, using the blob snapshot from the last committed state rather than the potentially modified version in the CWD. Initially, it checks if the file is absent in both the `STAGING_DIR` and the `CWD`. If the file is not found, it throws an error indicating **there is no justification to remove a non-existent file**. If the file exists in the `STAGING_DIR`, it is deleted from the addition staging area. The function then verifies if the last commit on the current working branch (obtained using `getHeadCommit`) contains the blob snapshot for this file (using file name to retrieve from `files` hashmap). If such a snapshot exists, it copies the content (reflecting the fileâ€™s status at the last commit) to the `STAGING_RM_DIR` under the original file name. Subsequently, it deletes the file from the `CWD`. **The rationale behind using the blob snapshot instead of the CWD version** is that the CWD file might have been modified post-commit but not yet committed. Storing these uncommitted modifications in the removal staging area and later restoring them could reintroduce uncommitted content. To maintain the integrity of the version history, it is essential only to track files as they were at their last committed state. Thus, any uncommitted contents are considered temporary and may not be preserved, ensuring that only committed file contents are stored between actions to maintain consistent file history. **Note**: After moving the files to the removal staging area, they are then deleted and their blob information is untracked in the files hashmap by the `commit` command with help of `Commit.helperCommit()` function. In the `Commit.helperCommit()` function, each file in the removal staging area is removed from the files hashmap and then deleted from the removal staging area. **Note**: this command will not erase the file name from `files` hashmap.

8. `getHeadCommit`: This function retrieves the most recent commit on the active working branch by accessing the `headMasterMap`.

9. `commandLog`: This function generates a log of Git history of **current working branch** (different from `global-log`). It utilizes the `printInfo()` function to display each commit's details. To trace back through the parent commits, the function employs a data structure similar to a **linked list**. Each commit acts as a node with a reference to its predecessor, mimicking the **'previous node'** in a linked list. This reference is maintained via a pointer that indicates the commit ID of the parent commit stored in the current commit's parent attribute. By accessing the parent commit's information, `Utils.readObject()` is used to retrieve and set the parent commit as the current commit, effectively moving the pointer up the linked list to continue the log trace. **Note**: When generating a new commit, the parent commit is identified as the last commit in the current working branch, which can be retrieved from the `headMasterMap`. The concept of a second parent commit will be addressed separately. To trace back to a parent commit, the commit ID is stored as a string in the parent attribute of the current commit. This ID is read, and the parent commit is retrieved accordingly. For parent attribute, it is the commitID but not path of commit file, as the `headMasterMap` stores <branch, commitID> as key-value pair. 

10. `commandGlobalLog`: This function is designed to display all commits across all branches, unlike the `log` command which is branch-specific. It iterates through a list of all commit filenames, which are obtained using the `Utils.plainFilenamesIn` method. For each commit, it retrieves the commit's details and then uses the `printInfo()` function to display information (`commid ID`, `timestamp`, `commit message` and `parent commit ID` (if it is a merged commit)).

11. `printInfo`: This function serves as a helper for the `log` and `global-log` commands. By default, it displays the `commit ID`, `timestamp`, and `commit message`. However, in cases where the commit includes two parents (indicating a merge commit), it additionally displays the commit IDs of both parents. This extra information is only shown for merge commits.

12. `commandFind`: This function is designed to print out the commit IDs of all commits that contain a specific commit message, which must be passed as an argument enclosed in quotation marks (""). It works by iterating through all files in the `COMMIT_DIR` directory to identify commits whose messages match the provided argument. If a match is found, the commit ID is printed (each takes a seperate line).

13. `commandStatus`: This function is designed to display what branches currently exist, and marks the current working branch with a `*`. Also displays what files are staged for addition or staged for removal. Noting that we don't realize the last two status `Modifications Not Staged For Commit` and `Untracked Files`. The function first retrieves the active working branch from the `headMasterMap` and indicates it with an asterisk (*). It then identifies and lists other branches that are not currently active. Next, the function checks for files in both the `addition staging directory` and the `removal staging directory`, and displays the names of these files.

14. `commandRestore`: This function is used to revert files back to their previous version. Depending on the arguments, there's 2 different usage of restore: using file name alone or using commid id with file name.\
a. `java VCS.Main restore -- [file name]`\
Takes the version of the file as it exist in the **head commit** and puts it in the working directory, overwrting hte version of the file that's alaready there if there is one. The new version of the file is not staged.\
b. `java VCS.Main restore [commit id] -- [file name]`\
Takes the version of the file as it exist in the **commit with the given id** (could be not active branch), and puts it in the working directory, overwriting the version of the file that's laready there if there is one. THe new version of the file is not staged.\ 
Noting this restore will not consider as a commit, thus it will not shown in the log.\

15. `commandRestore`: This function begins by checking if `args[1]` or `args[2]` is "--" to determine the specific variant of the restore command to execute. If `args[1]` equals "--", it retrieves and restores the most recently committed version of the specified file from the active branch. Alternatively, if `args[2]` equals "--", the function searches for the specified commit ID within the commit directory to locate the relevant commit file. It then reads this commit file to acquire its hash map of files (utilizing the `getCommitFiles` function) and proceeds to overwrite the corresponding files in the Current Working Directory (CWD) using the `overWriteInWorkDir` function. The function recognizes two possible formats of commit IDs: a short form consisting of the first 6 characters and a full-length form of 40 characters. It initially determines the length of the provided commit ID and checks its correspondence with the expected substrings. If no matching commit ID is found in the commit directory, the function issues an error stating "No commit with that id exists."

16. `overWriteInWorkDir`: The helper function used in the `restore` function, takes two parameters: a hash map `files` containing all tracked files along with their paths for a specific commit, and the target `fileName` that needs to be restored. This function first verifies if the hash map contains a key corresponding to `fileName`. If such an entry doesn't exist, it throws an error indicating `the file is not present in that commit`. If the file exists in the hash map, the function reads its contents and then either overwrites the existing file in the Current Working Directory (CWD) or creates a new file if it doesn't already exist there.

17. `getCommitFiles`: This function assists in retrieving a hash map of files that correspond to file blobs, which is utilized in the restore function. It takes the commit ID as the argument to search for the corresponding commit in the `commit` directory. 

18. `branchCommand`: This function creates a new beranch with the given name, and points it at the current head commit. A branch is nothing more than a name for a reference (a SHA-1 identifier) to a commit node. This command doe NOT immediately switch to the newly created branch (different from `checkout -b [branch name]` in real git that immediately shift to newly creating branch). Before you ever call branch, you code should be running with a default branch called "main". If the given branch name is already exist, the funciton will print the eeror message "A branch with that name already exists." 

19. `commandBranch`: This function begins by verifying if the specified branch name already exists. If it does, the function displays the error message "A branch with that name already exists." and terminates. If the branch name does not exist, the function retrieves the most recent commit and adds a key-value pair consisting of `{branchName, commitID}` to the `headMasterMap`. Additionally, to mark this commit as a split point, the function stores another key-value pair, `{"split", commitID}`, in the `headMasterMap`.

20. `commandRmBranch`: This function removes a branch from the `headMasterMap`. If the specified branch name does not exist, it displays an error message: "A branch with that name does not exist." If the branch name provided corresponds to the currently active branch, the function will display another error: "Cannot remove the current branch." If neither of these conditions is met, the function proceeds to remove the specified branch from the `headMasterMap` and updated hashmap will be saved.

21. `commandSwitch`: Switches to the branch with the given name. Takes all files in the commit at the head of the given branch, and puts them in the working directory, overwriting the visions of the files that are already there if they exist. Also, at the end of this comamnd, the given branch will now be considered the current branch (HEAD). Any files that are tarcked in teh current bracn but are not present in the checked-out branch are deleted. The staging area is cleared, unless teh checked-out branch is the current branch (Failure case). If no branch with that name xists, print No such branch exists. If that branch is the current branch, print No need to the current branch. If a working file is untrakced in the current branch and would be overwritten by the switch, print "there is an untrackiked file in the way: delete it, or add and commit it first." and exit. Perform this check before doing anything else. CWD is not changed. 

22. `commandReset`: Restore all the files tracked by the given commit. REmoves tracked files that are not present in that commit. Also moves the current branch's head to that commit node (no branch conversion). The `commid id` may be abbreviated (6-characters) like for `restore`. The staging area is cleared. If not commit with the given id exists, print "No commit with that id exists". If a working file is untracked in the current branch and would be overwritten by the reset, print "There is an untracked file in the way; delete it, or add and commit it first." and exit. Perform this check before doing anything else. 

23. `helperSwitchReset`: This is the helper function of `switch` and `reset` command. 
### Commit Class

#### Fields
**class member**
1. `message`: the message of this commit
2. `timeStamp`: the time stamp of this commit
3. `parent`: the parent commit ID of this commit (maybe more than one): for rolloing back. When generating a commit, the parent commit is considered as the last commit in the working branch (read the information from `headMasterMap`).
4. `parent2`: the 2nd parent commit ID of this commit
5. `files`: File pointer to blobs. `<file name, blob_ID>`
6. `commitID`: hash code for each commit

**class methods**
1. `Commit(String message)`: this function is designed for straightforward scenarios where there is only one parent commit, typically not involving a branch split. After reading `headMasterMap` file, tt begins by identifying the active branch using the HEAD pointer and retrieves the most recent commit from this branch to serve as the parent for the new commit. The function then accesses all related blob files for the current branch, which are stored in the `file` hashmap (inherited from the class member **file** of parent commit). It proceeds by invoking the `helperCommit` function to commit files that are staged for addition, removes files in the staging area set for deletion, and generates a unique commitID. Finally, it saves this new commit under the current branch in the headMasterMap. **Note**: Along with blob conversion from staging files, the commit command will put the addtion staging file name in `files` hashmap (tracked). For files in removal staging area, the files will deleted from this directory as well as as erased from `files` hashmap (untrack).

2. `helperCommit`: First, the function retrieves the lists of files that are staged for addition and removal from the directories `STAGING_DIR` and `STAGING_RM_DIR`, respectively. If both lists are empty, the system outputs "No change added to the commit" and exits successfully. This is consistent with our previous discussion that an empty staging area is detected and reported during the commit action. Next, the function calls `moveFilesSTOB` to transform all files in the addition staging area into blob snapshots, storing each **<file name, blob id>** pair in the files hashmap of `this` commit. The function then processes the removal staging area by iterating over all files in `STAGING_RM_DIR`. If any file is found in the current `files` hashmap, it is `erased` from the hashmap, and the file itself is `deleted` from the removal staging area. Finally, the function generates a commit ID for the new commit. It updates the `headMasterMap` with the commit ID, associating it with the currently active branch, and saves the commit information (a commit file) to the commit directory by `saveCommit` function.

3. `moveFileSTOB`: this function convert all stagedFiles in adding stage area into blob sanp shot using sha1 hashing function. This function processes files in the `STAGING_DIR` by converting each staged file into a blob snapshot. During this conversion, it employs `Utils.readContentsAsString()` to read the file contents as a string. It then generates a `blobID` by hashing the combination of the file name and string contents using `Utils.sha1()`. The `Files.copy()` function is used to duplicate the original file's contents into a new file named by the sha1 blobID, effectively creating the blob snapshot. The `Files.copy(sourcePath, desPath.resolve(blobID))` function in Java copies the content of the source file directly to the destination file without altering the content, hashing it, or converting it into a byte stream. After successfully creating each blob snapshot, the file's name and its corresponding blobID are recorded in the `files` hashmap of `this` commit. Once converted, the original files in the `STAGING_DIR` are deleted.

4. `genCommitID`: This function generates a CommitID by hashing a combination of all Commit class variables, including files, parents, message, and timestamp, using the `Utils.sha1()` function. This process ensures that each CommitID uniquely represents the specific state and content of the commit.

5. `saveCommit`: This function converts the commit information (all its class variables but not methods) into a byte stream and writes it to a file. The file is named with Commit ID (generated by `genCommitID`) and is stored in the COMMIT_DIR directory. This method ensures that each commit's details are serialized and preserved uniquely, facilitating easy retrieval and reference.

## Algorithms
### HashMap 
We utilize a hashmap called `headAndMaster` (HashMap<String, String>) to keep track of the active head pointer and information about all branches. The key **head** specifies the branch currently in use by the program. Additionally, multiple branch keys track the latest commits (may not be the newest, as we may roll back) for each branch. Each commitId associated with these branches helps locate the commit blob snapshot stored within `.gitlet`.

We use a hashmap named `files` (HashMap<string, string>), which is class member of the Commit class, to maintain a record of all files associated with this commit. The keys in this hashmap are the names of successfully committed files, while the values are the path of blob snap shot (directory path + blob ID). Blob ID consists of the file name plus file contents hashed using sha1. This files hashmap is inheritable by child commits. Any new files committed by child commits are added to this hashmap and incorporated into their commit information.

### Linked List
We utilize the linked list data structure to effectively track the parent commit of each commit. This setup is crucial for commands that need to access historical data of the current commit, such as `log`, `restore`, and `merge`. By default, the first parent commit is the most recent commit on the current working branch. New commits are then added sequentially as child commits to this parent. The linked list structure looks like this:\
**init commit (parent of commit 1) <- commit 1 (parent of commit 2) <- commit 2 ...**\
The commit ID of the parent is stored in the `parent` attribute of each commit. To trace the history of a branch, we start by reading the last commit, retrieving the commit ID of its parent from the parent attribute, and continue accessing each parent commit sequentially until reaching the `init` commit.

### SHA1 (Secure Hash Algorithm)
THis is a cryptographic hash function designed to convert data into a fixed size (160 bits, ot 20 bytes) has value. This hash value is typically represented by a **40-digit hexadecimal number**. We use SHA1 for generating both `CommitID` and `blobID`. The principle of SHA-1 like other fucntions, aim to satisfy basic attributes: **Uniqueness, Irreversibility, Fast computation, Collision Ressistance**. 

Below is the working priciple of the `sha1` function:
1. Initialization: The method starts creating a `MessageDigest` object for SHA1 computation through `MessageDigest..getInstance("SHA-1")`.
2. Updating Data: The function iterate over all provided arguments (`vals` array in the function arguments). Depending on the type of the argument (`byte[]` or `String`). It updates the hash computation data differently. If it is a string, it first converts the string into bytes using UTF-8 encoding, then updates the hash data
3. Computing the Hash Value: The `md.digest()` completes the hash calculation for all input data, returning a byte array representing the hash value.
4. Formatting the Hash Value: A `Formatter` is used to format the **byte** array into a **hexadecimal string**. Each byte is converted into a two-digit hexadecimal number. 
5. Exception Handling: if the SHA1 algorithm is unavaible in the system, it catcehs a `NoSuchAlgorighmExcemption` and thrown an `IllegalArgumentException`.

### Blob Snapshots and Commit Files
Blobs, or snapshots, are utilized to store versions of different files. In the commit's hash map (`files`), the file name is stored as a key, and its corresponding path is stored as the value (blob ID, SHA1 hashed). This value can help us find the corresponding blob in `blob` directory. This setup allows for the management of different versions of the same file (identical file names) by using the `commit ID` to determine which version of the file blob should be restored. If a commit ID is not specified, the Version Control System (VCS) automatically tracks and retrieves the most recently committed version from the currently active branch.

Commit files store all the variables of the Commit class, excluding functions. Each commit file is named after its respective commit ID. This naming convention is particularly useful for tracking specific commits, accessing files within a commit, or reverting to a previous version of a commit.

## Persistence
This file stores all instance variables of the Repository class with a useful comment above them describing what that variable represents and how that variable is used.

1. `CWD`: The current working directory (lu_version_control_project)
2. `GITLET_DIR`: The .gitlet directory in CWD
3. `STAGING_DIR`: The staging directory for add (seperate from remove). The adding stage file list can be obtained from this dir using `Utils.mehtod`
4. `STAGING_RM_DIR`: The staging directory for remove. The removing stage file list can be obtained from this dir using `Utils.mehtod`
5. `COMMIT_DIR`: The commit directory, containing all commit files (name: commitID, content: serialization using Utils).
6. `BLOB_DIR`: The directory storing blob snapshot. Blob ID = sha1(file_name + file_contents)
7. `HEAD_MASTER`: The head and master pointer information file. HashMap: <HEAD, live branch>; <branch, lastest commit>

