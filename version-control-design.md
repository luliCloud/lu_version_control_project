# Version Control System Design Document

## Classes and Data Structures

### Main Class

#### Fields

1. `Main function`: this function receive arguments to execute the git command, with the arguments are formatted as `[comamnd] [operand1] [operand2]...`. For example: `java CVS.Main [add] [file1] [file2]`. Initially, the main function determine how many arguments are received. If no argument are provided, it displays an error message. If one or more arguments are available, the function uses the first argument to match the `init` command (not included in `switch`) and other cases in `switch`statement. If the command does not match any keyword, it displays an error message stating that the command is invalid. If the operands number of format after command does not match the requirement of that command, it displays an error message stating that the operands are invalid.

2. `commandInit`: This function starts with the `initGitlet` function. This function leverages the Commit class to create the initial commit object, referred to as "commit 0". This commit is assigned a new ID, and all related information is captured in the first blob snapshot. Subsequently, a hashmap is created to manage the details of the active head pointer and the current active branch, which defaults to "main". In this initial hashmap, two key-value pairs are established: one maps <HEAD, main>, and the other maps <main, commit0_ID>. This hashmap, referred to as headAndMaster, is then saved to a file (headAndMaster) for future reference. The hashmap information is serialized into a byte stream using the Utils function, which handles the writing of this data to persistent storage.

3. `initGitlet`: this function makes two persistences if not exist: .gitlet and .gitlet/commit. The two are used to initialize a new git repository. commit folder will store the first commit blob snapshot (for init commit). 

4. `commandAdd`: This function first checks for the keyword "add" and counts the arguments that follow. If any required persistences are missing, it establishes the necessary ones. Then, it adds all the files specified in the arguments to the `STAGING_DIR` by invoking the `addToStage` function. **Note**: the add action will not add staging files to `files` hashmap (untracked).

5. `addToStage`: Helper funciton of `commandAdd`. This function duplicates the original file from the Current Working Directory (CWD) to the addition staging directory. The file is first copied to the adding staging area, with its content and format preserved identically to the original (**pre-staging**). If a file with same name already exist in the addition staging directory, it will be overwrriten. The function then retrievs the `files` hashmap <file_name, blob_id> from the parent commit.  Next, the function checks if the file hashmap already contains a file with the same name as pre-staging file. If such a file exists, the function generates the blob ID of pre-staging file (computed using utils.sha1(file name + file contents)) and then compares this hashing blobID (string) with the blod_id of the file with the same file name already stored in `files` hashmap. If they are identical, the file in the pre-staging area is removed (meaning this addition action fails because the file is already committed with identical content, not no error message shown here). As a result, the second `add` command acts like unstage commnad to call back any identical file (name and contents) added to addtion staging area. Subsequently, the commit command will verify whether the staging area is empty. 

6. `setupPersistence`: this functions sets up three persistences in .gitlet: direcory for staging files to be added, staging files to be removed, and blob files of all commits.

7. `commandRemove`: This function assists in removing files from the Current Working Directory (`CWD`) while preserving a copy in the `STAGING_RM_DIR`, using the blob snapshot from the last committed state rather than the potentially modified version in the CWD. Initially, it checks if the file is absent in both the `STAGING_DIR` and the `CWD`. If the file is not found, it throws an error indicating **there is no justification to remove a non-existent file**. If the file exists in the `STAGING_DIR`, it is deleted from the addition staging area. The function then verifies if the last commit on the current working branch (obtained using `getHeadCommit`) contains the blob snapshot for this file (using file name to retrieve from `files` hashmap). If such a snapshot exists, it copies the content (reflecting the file’s status at the last commit) to the `STAGING_RM_DIR` under the original file name. Subsequently, it deletes the file from the `CWD`. **The rationale behind using the blob snapshot instead of the CWD version** is that the CWD file might have been modified post-commit but not yet committed. Storing these uncommitted modifications in the removal staging area and later restoring them could reintroduce uncommitted content. To maintain the integrity of the version history, it is essential only to track files as they were at their last committed state. Thus, any uncommitted contents are considered temporary and may not be preserved, ensuring that only committed file contents are stored between actions to maintain consistent file history. **Note**: After moving the files to the removal staging area, they are then deleted and their blob information is untracked in the files hashmap by the `commit` command with help of `Commit.helperCommit()` function. In the `Commit.helperCommit()` function, each file in the removal staging area is removed from the files hashmap and then deleted from the removal staging area. **Note**: this command will not erase the file name from `files` hashmap.

8. `getHeadCommit`: This function retrieves the most recent commit on the active working branch by accessing the `headMasterMap`.

9. `commandLog`: This function generates a log of Git history of **current working branch** (different from `global-log`). It utilizes the `printInfo()` function to display each commit's details. To trace back through the parent commits, the function employs a data structure similar to a **linked list**. Each commit acts as a node with a reference to its predecessor, mimicking the **'previous node'** in a linked list. This reference is maintained via a pointer that indicates the commit ID of the parent commit stored in the current commit's parent attribute. By accessing the parent commit's information, `Utils.readObject()` is used to retrieve and set the parent commit as the current commit, effectively moving the pointer up the linked list to continue the log trace. **Note**: When generating a new commit, the parent commit is identified as the last commit in the current working branch, which can be retrieved from the `headMasterMap`. The concept of a second parent commit will be addressed separately. To trace back to a parent commit, the commit ID is stored as a string in the parent attribute of the current commit. This ID is read, and the parent commit is retrieved accordingly. For parent attribute, it is the commitID but not path of commit file, as the `headMasterMap` stores <branch, commitID> as key-value pair. 

10. `commandGlobalLog`: This function is designed to display all commits across all branches, unlike the `log` command which is branch-specific. It iterates through a list of all commit filenames, which are obtained using the `Utils.plainFilenamesIn` method. For each commit, it retrieves the commit's details and then uses the `printInfo()` function to display information (`commid ID`, `timestamp`, `commit message` and `parent commit ID` (if it is a merged commit)).

11. `printInfo`: This function serves as a helper for the `log` and `global-log` commands. By default, it displays the `commit ID`, `timestamp`, and `commit message`. However, in cases where the commit includes two parents (indicating a merge commit), it additionally displays the commit IDs of both parents. This extra information is only shown for merge commits.

12. `commandFind`: This function is designed to print out the commit IDs of all commits that contain a specific commit message, which must be passed as an argument enclosed in quotation marks (""). It works by iterating through all files in the `COMMIT_DIR` directory to identify commits whose messages match the provided argument. If a match is found, the commit ID is printed (each takes a seperate line).

13. `commandStatus`: This function is designed to display what branches currently exist, and marks the current working branch with a `*`. Also displays what files are staged for addition or staged for removal. Noting that we don't realize the last two status `Modifications Not Staged For Commit` and `Untracked Files`. The function first retrieves the active working branch from the `headMasterMap` and indicates it with an asterisk (*). It then identifies and lists other branches that are not currently active. Next, the function checks for files in both the `addition staging directory` and the `removal staging directory`, and displays the names of these files.

14. `commandRestore`: This function is used to revert files back to their previous version. Depending on the arguments, there's 2 different usage of restore: using file name alone or using commid id with file name.\
a. `java VCS.Main restore -- [file name]`\
Takes the version of the file as it exist in the **head commit** and puts it in the working directory, overwrting hte version of the file that's alaready there if there is one. The new version of the file is not staged.\
b. `java VCS.Main restore [commit id] -- [file name]`\
Takes the version of the file as it exist in the **commit with the given id** (could be not active branch), and puts it in the working directory, overwriting the version of the file that's laready there if there is one. THe new version of the file is not staged.\ 
Noting this restore will not consider as a commit, thus it will not shown in the log.

15. `commandRestore`: This function begins by checking if `args[1]` or `args[2]` is "--" to determine the specific variant of the restore command to execute. If `args[1]` equals "--", it retrieves and restores the most recently committed version of the specified file from the active branch. Alternatively, if `args[2]` equals "--", the function searches for the specified commit ID within the commit directory to locate the relevant commit file. It then reads this commit file to acquire its hash map of files (utilizing the `getCommitFiles` function) and proceeds to overwrite the corresponding files in the Current Working Directory (CWD) using the `overWriteInWorkDir` function. The function recognizes two possible formats of commit IDs: a short form consisting of the first 6 characters and a full-length form of 40 characters. It initially determines the length of the provided commit ID and checks its correspondence with the expected substrings. If no matching commit ID is found in the commit directory, the function issues an error stating "No commit with that id exists."

16. `overWriteInWorkDir`: The helper function used in the `restore` function, takes two parameters: a hash map `files` containing all tracked files along with their paths for a specific commit, and the target `fileName` that needs to be restored. This function first verifies if the hash map contains a key corresponding to `fileName`. If such an entry doesn't exist, it throws an error indicating `the file is not present in that commit`. If the file exists in the hash map, the function reads its contents and then either overwrites the existing file in the Current Working Directory (CWD) or creates a new file if it doesn't already exist there.

17. `getCommitFiles`: This function assists in retrieving a hash map of files that correspond to file blobs, which is utilized in the restore function. It takes the commit ID as the argument to search for the corresponding commit in the `commit` directory. 

18. `commandBranch`: This function creates a new beranch with the given name, and points it at the current head commit. A branch is nothing more than a name for a reference (a SHA-1 identifier) to a commit node. This command doe NOT immediately switch to the newly created branch (different from `checkout -b [branch name]` in real git that immediately shift to newly creating branch). Before you ever call branch, you code should be running with a default branch called "main". If the given branch name is already exist, the funciton will print the eeror message "A branch with that name already exists." \
This function begins by verifying if the specified branch name already exists. If it does, the function displays the error message "A branch with that name already exists." and terminates. If the branch name does not exist, the function retrieves the most recent commit and adds a key-value pair consisting of `{branchName, commitID}` to the `headMasterMap`. Additionally, to mark this commit as a split point, the function stores another key-value pair, `{"split", commitID}`, in the `headMasterMap`.

19. `commandRmBranch`: This function removes a branch from the `headMasterMap`. If the specified branch name does not exist, it displays an error message: "A branch with that name does not exist." If the branch name provided corresponds to the currently active branch, the function will display another error: "Cannot remove the current branch." If neither of these conditions is met, the function proceeds to remove the specified branch from the `headMasterMap` and updated hashmap will be saved.

20. `commandSwitch`: Switches to the branch with the given name. Takes all files in the commit at the head of the given branch, and puts them in the working directory, overwriting the visions of the files that are already there if they exist. Also, at the end of this comamnd, the given branch will now be considered the current branch (HEAD). Any files that are tarcked in teh current bracn but are not present in the checked-out branch are deleted. The staging area is cleared, unless teh checked-out branch is the current branch (Failure case). If no branch with that name xists, print No such branch exists. If that branch is the current branch, print No need to the current branch. If a working file is untrakced in the current branch and would be overwritten by the switch, print "there is an untrackiked file in the way: delete it, or add and commit it first." and exit. Perform this check before doing anything else. CWD is not changed. 

21. `commandReset`: Restore all the files tracked by the given commit. REmoves tracked files that are not present in that commit. Also moves the current branch's head to that commit node (no branch conversion). The `commid id` may be abbreviated (6-characters) like for `restore`. The staging area is cleared. If not commit with the given id exists, print "No commit with that id exists". If a working file is untracked in the current branch and would be overwritten by the reset, print "There is an untracked file in the way; delete it, or add and commit it first." and exit. Perform this check before doing anything else. 

22. `helperSwitchReset`: This is the helper function of `switch` and `reset` command. 
The `switch` function begins by checking if the branchName parameter is not `null`. It retrieves the latest commit associated with the specified branch from the `masterHeadMap`. The function then examines the current working directory (CWD) to identify any files present in the CWD but not in the current branch's most recent commit, yet are in the most recent commit of the target branch to be switched to. If such files are found, they are considered untracked and will be mistakenly overwritten by the `switch` or `reset` command. This is dangerous for any unsaved files. In this case, the function will issue an error message stating, "There is an untracked file in the way; delete it, or add and commit it first," and the operation will be aborted.\
If the file exists in both the current and target branch's latest commits, it will be removed from the CWD and later replaced by this function. Once all conflicts with tracked and overlapping files are resolved, all files from the target branch's latest commit are copied to the CWD, and the staging area is cleared. The `HEAD` in `headMasterMap` is then updated to point to the new branch name.\
If `resetCommit` arguments is not `null`, which indicates a `reset` command. The `reset` command reverts any branch to an earlier version specified by a commitID. If a short 6-character commit identifier is provided, the function searches for the corresponding full commit ID within the `commit directory`. Once the appropriate commit file is located, its details are loaded into the `branchCommit` object.\
The function also initializes a string named `commitPointer`, which holds the most recent commit ID from the currently active branch. Initially, it tries to find the specified commit ID in the current branch (check parent of each commit and using the `linked list` algorithm described in the **Algorithm** section). If the commit is found in the current branch, no branch switching is required. If it is not found (`commitPointer`remains empty), the function searches all keys in `headMasterMap` for the commit ID. Here, keys that are not the name of the current working directory, nor "HEAD", nor labeled as "split", are considered potential branches containing the commit.\
However, this approach presents a design flaw as there could be multiple branches that fit these criteria, making it unclear which branch should be selected (we chose the first met in the iteration). Therefore, in a future version of this Version Control System (VCS) or in real-world applications like Git, **each commit object should ideally contain information about the branch it belongs to**, facilitating clearer and more accurate branch tracking and commit reversal.

23. `commandMerge`: This function merges files from the given branch into the current branch . This method is complicated, we will describe in details:\
a. First we have a concept of **split point**, which is the split point of the current branch and the given branch (see graph below):  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; commit 2 - commit 3  (main branch)*    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/  
commit 0 - commit 1 **(split point)**  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;commit 4 - commit 5  (other branch)  
`main` is the current brancha nd `branch` is the given branch. The split point is a latest commit ancestor of the current and given branch heads. The function initially handles several failure scenarios: i. If the specified branch does not exist, it throws an error stating "A branch with that name does not exist." and terminates the operation. ii. If the branch specified is the same as the currently active branch, it throws an error stating "Cannot merge a branch with itself.". iii. If there are uncommitted changes in the staging area, it throws an error stating "You have uncommitted changes." and exits the process.  
b. the remaining part of code segment ensures that branches are either fast-forwarded, identified as ancestors, or properly merged, maintaining the integrity and history of the project in the VCS:  
**Reading Commit Objects**: It retrieves the commit object associated with the head of the branch to be merged (branchHead) from the repository's commit directory using the branch name to access the relevant commit ID from headMap.
**Finding the Split Point**: The `findSplit` method is called with the current branch's head commit (curCommit) and the branchHead to determine their most recent common ancestor (split point).  Please see detailed description of `findSplit` in **Algorithm** section  
**Checking Ancestry**:   
i. If the split point's commit ID is the same as branchHead's (head of desired merged branch) commit ID, this implies that the branch to be merged is an ancestor of the current branch. A message "Given branch is an ancestor of the current branch." is printed to indicate this, and the program exits, as no merge is necessary. The scenario shown below:  
```
(desired merged branch) commit 0 - commit 1 (split point) - (current branch) commit 2 - commit 3 (`git merge derised-merged-branch`)  
```
ii. Ideally, if the split point's commit ID matches the curCommit's commit ID, this means the current branch can be "fast-forwarded" to the state of branchHead because branchHead is ahead of the current branch and no divergent changes have occurred. The `helperSwitchReset` function is then called to update the current branch's head to branchHead's commit, followed by a message "Current branch fast-forwarded." and program exit. The scenario shown below:   
```
(current working branch, switched back and head pointer to commit 1) commit 0 - commit 1 (split point) - (desired merged branch) commit 2 - commit 3 (`git merge derised-merged-branch`).  
```
**design flaw** for this scenario: The current implementation of the fast-forward function contains a design flaw. Ideally, this function should keep the current branch active and advance its last commit to match the latest commit of the branch intended for merging. However, due to the lack of specific conditions in the `helperSwitchAndReset` function, it inadvertently switches to the branch intended for merging and updates to its own latest commit. This results in the so-called current branch's (actually checkout) commit log remaining unchanged post-merge, while the `git status` indicates that the working branch has incorrectly switched to the merged branch. To address this in future versions of the Version Control System (VCS), a new algorithm will be designed. This algorithm will copy all commits from the merged branch that are subsequent to the split point to the current branch. It will then update the head pointer of the current branch to reflect the latest commit of the merged branch, while ensuring that the working branch remains unchanged. This adjustment will ensure that the fast-forward functionality properly merges branches without altering the active branch status.  
iii. If the commit IDs of the split point and branchHead do not match, and the split point's commit ID does not equal the curCommit's commit ID (indicating neither of heads are the split point), the code checks if branchHead is an ancestor of the current branch by walking back the commit chain (we cannot find a suitable for this scenario yet). This is done by iterating through the parent commits starting from the split point until no parent exists (i.e., reaching the root commit). If branchHead's commit ID is found during this iteration, it indicates that branchHead is indeed an ancestor, and a message "Given branch is an ancestor of the current branch." is printed with the program exiting subsequently.  
iv. If no ancestor relationship is detected, a new (merge) commit is created to represent the merge of the two branches (complicated version of `Commit constructor`). This new commit contains a message stating that one branch was merged into the other `"Merged " + branchName + " into " + headMap.get("HEAD") + "."`, and it includes references to the split point, curCommit, branchHead, and the branch name being merged. Or if the files have conflicts, a message "Encountered a merge conflict." will display and files will be overwritten by conflict content shown below. The merged execution is done by `Commit constructor` in `Commit` class. See explanation below:

### Commit Class

#### Fields
**class member**
1. `message`: the message of this commit
2. `timeStamp`: the time stamp of this commit
3. `parent`: the parent commit ID of this commit (maybe more than one): for rolloing back. When generating a commit, the parent commit is considered as the last commit in the working branch (read the information from `headMasterMap`).
4. `parent2`: the 2nd parent commit ID of this commit
5. `files`: File pointer to blobs. `<file name, blob_ID>`
6. `commitID`: hash code for each commit

**class methods**
1. `Commit(String message)`: this function is designed for straightforward scenarios where there is only one parent commit, typically not involving a branch split. After reading `headMasterMap` file, tt begins by identifying the active branch using the HEAD pointer and retrieves the most recent commit from this branch to serve as the parent for the new commit. The function then accesses all related blob files for the current branch, which are stored in the `file` hashmap (inherited from the class member **file** of parent commit). It proceeds by invoking the `helperCommit` function to commit files that are staged for addition, removes files in the staging area set for deletion, and generates a unique commitID. Finally, it saves this new commit under the current branch in the headMasterMap. **Note**: Along with blob conversion from staging files, the commit command will put the addtion staging file name in `files` hashmap (tracked). For files in removal staging area, the files will deleted from this directory as well as as erased from `files` hashmap (untrack).

2. `helperCommit`: First, the function retrieves the lists of files that are staged for addition and removal from the directories `STAGING_DIR` and `STAGING_RM_DIR`, respectively. If both lists are empty, the system outputs "No change added to the commit" and exits successfully. This is consistent with our previous discussion that an empty staging area is detected and reported during the commit action. Next, the function calls `moveFilesSTOB` to transform all files in the addition staging area into blob snapshots, storing each **<file name, blob id>** pair in the files hashmap of `this` commit. The function then processes the removal staging area by iterating over all files in `STAGING_RM_DIR`. If any file is found in the current `files` hashmap, it is `erased` from the hashmap, and the file itself is `deleted` from the removal staging area. Finally, the function generates a commit ID for the new commit. It updates the `headMasterMap` with the commit ID, associating it with the currently active branch, and saves the commit information (a commit file) to the commit directory by `saveCommit` function.

3. `moveFileSTOB`: this function convert all stagedFiles in adding stage area into blob sanp shot using sha1 hashing function. This function processes files in the `STAGING_DIR` by converting each staged file into a blob snapshot. During this conversion, it employs `Utils.readContentsAsString()` to read the file contents as a string. It then generates a `blobID` by hashing the combination of the file name and string contents using `Utils.sha1()`. The `Files.copy()` function is used to duplicate the original file's contents into a new file named by the sha1 blobID, effectively creating the blob snapshot. The `Files.copy(sourcePath, desPath.resolve(blobID))` function in Java copies the content of the source file directly to the destination file without altering the content, hashing it, or converting it into a byte stream. After successfully creating each blob snapshot, the file's name and its corresponding blobID are recorded in the `files` hashmap of `this` commit. Once converted, the original files in the `STAGING_DIR` are deleted.

4. `genCommitID`: This function generates a CommitID by hashing a combination of all Commit class variables, including files, parents, message, and timestamp, using the `Utils.sha1()` function. This process ensures that each CommitID uniquely represents the specific state and content of the commit.

5. `saveCommit`: This function converts the commit information (all its class variables but not methods) into a byte stream and writes it to a file. The file is named with Commit ID (generated by `genCommitID`) and is stored in the COMMIT_DIR directory. This method ensures that each commit's details are serialized and preserved uniquely, facilitating easy retrieval and reference.

6. `commit(complicated version)`: The Commit constructor is designed to handle the merging of two branches in a version control system. This constructor function can handle merging changes from one branch into another, including conflict resolution, file staging, and commit creation.  
**Components**: a. `Repository and File Retrieval`: The constructor starts by accessing the repository's HEAD information and file states from the latest commits of the `curBranch`, the branch to be merged (`givenBranch`), and their common ancestor (`split point`). b. `Conflict Detection and Handling`: Untracked File Detection: Before proceeding with the merge, the constructor scans the current working directory (CWD) for files that are not tracked by the current branch but are present in the branch to be merged. If such files are detected, the operation is halted to prevent potential data loss, and a message is displayed advising the user to resolve these files and the program exits.
**Merge Logic**: 
a. The funciton first checked the `files` hashmap of split point to see whether each file has been modified in either of children branches. The scanning results will result in whether files is deleted or staged or dealed with `conflict` function. The different conditions are discussed below:   
i. If a file has been modified in both branches since the split point without conflicts, the file from the branch being merged (`givenBranch`) is staged for addition, and the file contents in working directory is updated to version of `givenBranch` accordingly.  
ii. If a file has been modified since the `split point` and exists in both the current and the merged branches but with different contents, this situation is handled by a `conflict` resolution function.  
iii. File Exists in Current Branch but Not in Merged Branch: First Condition: If a file is present in the current branch, unmodified since the split point, it should be removed. This operation involves marking the file for deletion and moving it to a removal staging area, where it will later be untracked. Second Condition: If a file has been modified in the current branch, it should be retained in its current form. Any conflicts arising due to its absence in the merged branch are managed by the conflict resolution function, ensuring that the changes in the current branch are preserved.  
iv. File Does Not Exist in Current Branch but Exists in Merged Branch: if this file is modified in the merged branch compared to the split point, a conflict arises. 
b. the fucntion then check the `files` hashmap of merged branch to handle the conflict files:  
i. File Present Only in Merged Branch: If a file does not exist in either the split point or the current branch but is found in the merged branch, this file will be copied to the Current Working Directory (CWD). It is then moved to the additional staging area and begins to be tracked by the current branch.  
ii. File Absent in Split Point but Modified in Current Branch: If the split point does not contain a file, but the current branch has a file with the same name that differs in content, a conflict arises. This conflict will be addressed by the conflict resolution function to determine the appropriate action for merging changes or resolving discrepancies.
**Conflicting modifications**: are handled by a separate `conflict` method, which creates a merged file with conflict markers.
Deletion and Removal: Files that exist in the current branch but not in the branch being merged and haven't changed since the split point are staged for removal.
**Commit Creation specfic for merge commit**: `Parent Commit Setup`: The new commit will have two parent commits reflecting the heads of the merged branches, facilitating future merges and history tracking. `Files HashMap Update`: All changes (additions, deletions, modifications) are finalized in the staging area, and the file system state is updated to reflect the merge.
**Finalization**: `Helper Commit`: A helper method is invoked to complete the commit process, which includes moving files from the staging area to the repository's blob storage, updating the HEAD pointers, and serializing the updated state.

7. `Conflict`: Any files modified in different ways in the current and given branches are in conflict. "Modified in different ways" can mean that the contents of both are changed and different from other, or the contents of one are changed and teh other file is deleted, or the file was absent at the split point and has different contents in the given and current branches. In this case, this function replace the **conflit file** (not create a new file) to reflect the conflicts and a message "Encountered a merge conflict." will be displayed (commit is still successful, not exit or failure): 
```
<<<<<<< HEAD
[contents of file in current branch]

=======
[contents of file in given branch]
>>>>>>>
```
**Noting**: unlike the real git, out VCS project cannot make the fragment of conflict contents out but keep other context unchanged. As a simple version, we only display the whole contents of both files and let users to find out the differences. This isseu should be addressed in the next version. After the funcitons overwirtes this files with above contents (all original contents will be overwrittent), the file will copied to addtional stage area and tracked, committed by this merge commit later (finished by `commitHelper` function).  

## Algorithms
### HashMap 
We utilize a hashmap called `headAndMaster` (HashMap<String, String>) to keep track of the active head pointer and information about all branches. The key **head** specifies the branch currently in use by the program. Additionally, multiple branch keys track the latest commits (may not be the newest, as we may roll back) for each branch. Each commitId associated with these branches helps locate the commit blob snapshot stored within `.gitlet`.

We use a hashmap named `files` (HashMap<string, string>), which is class member of the Commit class, to maintain a record of all files associated with this commit. The keys in this hashmap are the names of successfully committed files, while the values are the path of blob snap shot (directory path + blob ID). Blob ID consists of the file name plus file contents hashed using sha1. This files hashmap is inheritable by child commits. Any new files committed by child commits are added to this hashmap and incorporated into their commit information.

### Linked List
We utilize the linked list data structure to effectively track the parent commit of each commit. This setup is crucial for commands that need to access historical data of the current commit, such as `log`, `restore`, and `merge`. By default, the first parent commit is the most recent commit on the current working branch. New commits are then added sequentially as child commits to this parent. The linked list structure looks like this:\
**init commit (parent of commit 1) <- commit 1 (parent of commit 2) <- commit 2 ...**\
The commit ID of the parent is stored in the `parent` attribute of each commit. To trace the history of a branch, we start by reading the last commit, retrieving the commit ID of its parent from the parent attribute, and continue accessing each parent commit sequentially until reaching the `init` commit.

### SHA1 (Secure Hash Algorithm)
THis is a cryptographic hash function designed to convert data into a fixed size (160 bits, ot 20 bytes) has value. This hash value is typically represented by a **40-digit hexadecimal number**. We use SHA1 for generating both `CommitID` and `blobID`. The principle of SHA-1 like other fucntions, aim to satisfy basic attributes: **Uniqueness, Irreversibility, Fast computation, Collision Ressistance**. 

Below is the working priciple of the `sha1` function:
1. Initialization: The method starts creating a `MessageDigest` object for SHA1 computation through `MessageDigest..getInstance("SHA-1")`.
2. Updating Data: The function iterate over all provided arguments (`vals` array in the function arguments). Depending on the type of the argument (`byte[]` or `String`). It updates the hash computation data differently. If it is a string, it first converts the string into bytes using UTF-8 encoding, then updates the hash data
3. Computing the Hash Value: The `md.digest()` completes the hash calculation for all input data, returning a byte array representing the hash value.
4. Formatting the Hash Value: A `Formatter` is used to format the **byte** array into a **hexadecimal string**. Each byte is converted into a two-digit hexadecimal number. 
5. Exception Handling: if the SHA1 algorithm is unavaible in the system, it catcehs a `NoSuchAlgorighmExcemption` and thrown an `IllegalArgumentException`.
t
### Blob Snapshots and Commit Files
Blobs, or snapshots, are utilized to store versions of different files. In the commit's hash map (`files`), the file name is stored as a key, and its corresponding path is stored as the value (blob ID, SHA1 hashed). This value can help us find the corresponding blob in `blob` directory. This setup allows for the management of different versions of the same file (identical file names) by using the `commit ID` to determine which version of the file blob should be restored. If a commit ID is not specified, the Version Control System (VCS) automatically tracks and retrieves the most recently committed version from the currently active branch.

Commit files store all the variables of the Commit class, excluding functions. Each commit file is named after its respective commit ID. This naming convention is particularly useful for tracking specific commits, accessing files within a commit, or reverting to a previous version of a commit.

### Find Split Point
This `find split` algorihtm is similar to the algorithm question that `find the split point in two linked lists (leetcode)` and is designed to identify the most recent common ancestor (or split point) between two branches in a version control system. Here's a detailed explanation of how the code operates:

**Initialization**:
Two Commit objects, head1 and head2, are initialized to represent the latest commits of the main branch and the branch to be merged, respectively. If both heads have the same commit ID, they are identical, meaning the split point is the commits themselves, so head1 is immediately returned.  
**Setup for Ancestor Tracking**:
Two `Set<String>` objects, p1 and p2, are used to track the ancestor commit IDs of head1 and head2. Each set initially contains the IDs of the parents of head1 and head2. This includes both direct parents and second parents (to handle merge commits which might have two parents).  
**Finding the Common Ancestor**:
A while loop continues as long as there is no intersection between the sets p1 and p2. Inside the loop, intersections of p1 and p2 are checked. If there is an intersection (i.e., a common commit ID), and it's not an empty string, this commit is read from the repository and returned as the split point. If no intersection is found, the loop proceeds to update p1 and p2 with the parent commit IDs of the current contents of p1 and p2.  
**Expanding Search**:
**key point of this algorithm: For both p1 and p2, for each commit ID in the current set: If only an empty string remains, indicating no further ancestors for that branch, the ID of the other head is added (indicative of reaching the initial commit without finding a common ancestor). i.e., switch the head pointer to other branch** If there are valid commit IDs, their parent commit IDs are obtained and added to the set for the next iteration. This effectively traverses backwards through the ancestry of each branch simultaneously.  
**Final Intersection Check**:
After exiting the loop (when p1 and p2 intersect), a final check for any common elements in p1 and p2 is performed. The first valid commit found in this intersection is read from the repository and returned.  
**Return**:
If no split point is found (i.e., no intersection contains valid commit IDs), the method returns null.  
The method uses breadth-first search strategy by progressively exploring the parents of each commit, thereby tracing back the genealogy of both branches until it finds a common ancestor. This approach handles complex histories, including branches created from merges, ensuring that the correct split point is identified in the case of divergent branch histories.

## Persistence
This file stores all instance variables of the Repository class with a useful comment above them describing what that variable represents and how that variable is used.

1. `CWD`: The current working directory (lu_version_control_project)
2. `GITLET_DIR`: The .gitlet directory in CWD
3. `STAGING_DIR`: The staging directory for add (seperate from remove). The adding stage file list can be obtained from this dir using `Utils.mehtod`
4. `STAGING_RM_DIR`: The staging directory for remove. The removing stage file list can be obtained from this dir using `Utils.mehtod`
5. `COMMIT_DIR`: The commit directory, containing all commit files (name: commitID, content: serialization using Utils).
6. `BLOB_DIR`: The directory storing blob snapshot. Blob ID = sha1(file_name + file_contents)
7. `HEAD_MASTER`: The head and master pointer information file. HashMap: <HEAD, live branch>; <branch, lastest commit>

